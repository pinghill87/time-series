---
title: "Multivariate TS Models (ARIMAX/SARIMAX/VAR)"
code-fold: true
---

## Introduction

In this analysis, we investigate the relationships between cryptocurrency markets (Bitcoin), traditional equity markets (S&P 500), market volatility (VIX), and macroeconomic indicators (CPI). Understanding these relationships is crucial for portfolio diversification, risk management, and forecasting in modern financial markets.

## Literature Review

### Background and Variable Selection

Financial markets exhibit complex interdependencies that have evolved significantly with the emergence of cryptocurrency markets. According to **Nakamoto (2008)** and subsequent cryptocurrency research, Bitcoin was designed as a decentralized alternative to traditional fiat currencies. However, empirical studies by **Baur & Dimpfl (2018)** show that Bitcoin increasingly behaves like a traditional financial asset, responding to macroeconomic and market conditions.

The **S&P 500** serves as a broad measure of U.S. equity market performance and overall economic health. Research by **Corbet et al. (2018)** demonstrates significant spillover effects between traditional equity markets and cryptocurrency markets, particularly during periods of market stress. During the COVID-19 pandemic, both Bitcoin and the S&P 500 experienced simultaneous crashes, suggesting increasing correlation.

The **VIX** (CBOE Volatility Index), often called the "fear gauge," measures expected market volatility. Studies by **Whaley (2009)** establish the VIX as a leading indicator of market sentiment. Recent research by **Smales (2019)** shows that Bitcoin exhibits increased correlation with traditional markets during high-volatility periods, suggesting that market fear affects all asset classes. The inverse relationship between VIX and S&P 500 is well-documented, with VIX typically rising when stock prices fall.

The **U.S. Dollar Index (USD)** summarizes the value of the U.S. dollar against a basket of major currencies. Dollar strength is linked to global risk sentiment and capital flows. A stronger dollar is often associated with tighter global financial conditions and may put pressure on risky assets such as equities and cryptocurrencies.

The **NASDAQ Composite Index** serves as a growth-oriented measure of U.S. equity performance, with a heavy weighting toward technology firms. Prior work (e.g., Corbet et al. 2020) suggests that cryptocurrency markets often co-move more strongly with technology-driven equity indices than with broad-market indices such as the S&P 500. The NASDAQ therefore provides an additional lens for examining equity–crypto linkages, particularly during periods of rapid innovation or heightened risk appetite.

**Variable Justification**:

Based on this literature, I focus on the following relationships:

1. **Bitcoin returns** may be influenced by traditional market performance (SP500) and market volatility/fear (VIX).
2. **SP500 and VIX** have a well-documented inverse relationship—when stocks fall, fear rises.
3. **Dollar strength (USD)** may be related to risk sentiment and interact with equity and crypto markets.
4. These variables likely exhibit **dynamic and possibly bidirectional** relationships, motivating multivariate time series models.


---

## Key Research Questions

1. **How does market fear (VIX) affect Bitcoin and S&P 500 returns?**
2. **What is the relationship between traditional markets (S&P 500) and cryptocurrency markets (Bitcoin)?**
3. **Does including multiple series (Bitcoin, SP500, VIX, USD) in multivariate models improve forecasting compared to univariate ARIMA?**
4. **Do these variables exhibit bidirectional causality (VAR) or mainly unidirectional effects (ARIMAX)?**


---

## Proposed Models

Based on the literature and data availability, I estimate the following models:

**Model 1 (ARIMAX)**: Bitcoin_ret ~ SP500_ret + VIX_ret  
- *Rationale*: Test whether Bitcoin returns are driven by traditional market performance and market fear.

**Model 2 (ARIMAX)**: SP500_ret ~ Bitcoin_ret + VIX_ret  
- *Rationale*: Examine how cryptocurrency returns and volatility interact with equity returns.

**Model 3 (ARIMAX)**: VIX_ret ~ Bitcoin_ret + SP500_ret  
- *Rationale*: Test whether movements in equities and Bitcoin help explain changes in implied volatility.

**Model 4 (ARIMAX)**: USD_ret ~ Bitcoin_ret + SP500_ret  
- *Rationale*: Explore how equity and crypto markets relate to changes in the broad U.S. dollar index.

**Model 5 (VAR)**: [Bitcoin_ret, SP500_ret, VIX_ret]  
- *Rationale*: Capture bidirectional relationships and dynamic interactions among cryptocurrency, equities, and volatility.

**Model 6 (ARIMAX)**: NASDAQ_ret ~ SP500_ret + VIX_ret
- *Rationale*: Assess whether NASDAQ movements are primarily driven by broad equity conditions and market volatility, and whether NASDAQ behaves similarly or differently from the S&P 500 when exposed to market stress.


---

## Data Preparation

::: {.panel-tabset}

### Data Loading

```{r}
#| warning: false
#| message: false
suppressPackageStartupMessages({
library(quantmod); library(zoo); library(xts)
library(tidyverse); library(forecast); library(tseries)
library(ggplot2)
})
```

```{r}
#| warning: false
#| message: false



start_date <- as.Date("2019-01-01")
end_date   <- as.Date("2025-09-18")



load_fred_data <- function(symbol, start, end) {
tryCatch({
getSymbols(symbol, src = "FRED", from = start, to = end, auto.assign = FALSE)
}, error = function(e) {
cat(sprintf("Warning: Could not load %s (%s)\n", symbol, e$message))
NULL
})
}

# Load and merge 

if (!exists("price_data") ||
!all(c("Date","SP500","VIX","Bitcoin","USD") %in% names(price_data))) {

sp500_data <- load_fred_data("SP500",    start_date, end_date)
vix_data   <- load_fred_data("VIXCLS",   start_date, end_date)
btc_data   <- load_fred_data("CBBTCUSD", start_date, end_date)
usd_data   <- load_fred_data("DTWEXBGS", start_date, end_date)
nasdaq_data <- load_fred_data("NASDAQCOM", start_date, end_date)  

merged <- merge(
SP500   = sp500_data,
VIX     = vix_data,
Bitcoin = btc_data,
USD     = usd_data,
NASDAQ  = nasdaq_data
)

price_data <- fortify.zoo(merged)
colnames(price_data) <- c("Date","SP500","VIX","Bitcoin","USD", "NASDAQ")
price_data <- price_data |> arrange(Date) |> na.omit()
}

# Daily log-returns 

returns <- price_data |>
mutate(
SP500_ret   = c(NA, diff(log(SP500))),
VIX_ret     = c(NA, diff(log(VIX))),
Bitcoin_ret = c(NA, diff(log(Bitcoin))),
USD_ret     = c(NA, diff(log(USD))),
 NASDAQ_ret  = c(NA, diff(log(NASDAQ)))  
) |>
na.omit()

cat(
  sprintf(
    "Data loaded — SP500: %d | VIX: %d | BTC: %d | USD: %d | NASDAQ: %d\n",
    nrow(sp500_data),
    nrow(vix_data),
    nrow(btc_data),
    nrow(usd_data),
    nrow(nasdaq_data)
  )
)



```

:::

## Bitcoin

::: {.panel-tabset}

### Visualization

```{r}
#| label: btc-viz
#| warning: false
#| fig.width: 10
#| fig.height: 5
#| 
p1 <- ggplot(price_data, aes(Date, Bitcoin)) +
geom_line() + theme_minimal() + labs(title="Bitcoin (Level)", x=NULL, y=NULL)
p2 <- ggplot(returns, aes(Date, Bitcoin_ret)) +
geom_line() + theme_minimal() + labs(title="Bitcoin (Log-Returns)", x=NULL, y=NULL)
gridExtra::grid.arrange(p1, p2, nrow=2)

```

### Variable Selection

```{r}
#| warning: false


cm <- cor(returns[, c("Bitcoin_ret","SP500_ret","VIX_ret")], use="complete.obs")
print(round(cm, 3))

# Stationarity (ADF) on returns

adf_btc <- adf.test(returns$Bitcoin_ret)
adf_spx <- adf.test(returns$SP500_ret)
adf_vix <- adf.test(returns$VIX_ret)
cat(sprintf("ADF p-values → BTC: %.4f | SPX: %.4f | VIX: %.4f\n",
adf_btc$p.value, adf_spx$p.value, adf_vix$p.value))

```

Bitcoin returns were modeled using SP500 and VIX as predictors. BTC is modestly correlated with SPX (0.28) and weakly negatively correlated with VIX (–0.22). All series are stationary (ADF p = 0.01), so they are appropriate exogenous regressors.

### Initial Selection

```{r}
#| warning: false

# Assemble y and scaled xreg

y   <- as.numeric(returns$Bitcoin_ret)
X   <- as.matrix(returns[, c("SP500_ret","VIX_ret")])
XS  <- scale(X)  

# Auto.ARIMA 

m_btc_auto <- forecast::auto.arima(y, xreg = XS, seasonal = FALSE)
cat("AUTO.ARIMA with xreg summary:\n"); print(summary(m_btc_auto))

# Manual: OLS then ARIMA on residual

ols <- lm(y ~ XS)
res <- resid(ols)
res_arima <- forecast::auto.arima(res, seasonal = FALSE)
ord <- arimaorder(res_arima)
m_btc_manual <- Arima(y, order = ord, xreg = XS, include.mean = TRUE)
cat("\nMANUAL ARIMAX summary:\n"); print(summary(m_btc_manual))

```

Both AUTO.ARIMA and manual testing selected the same structure:
ARIMAX(0,0,1) with SP500_ret and VIX_ret as predictors.
SP500_ret has a small positive effect on BTC returns, while VIX_ret has a very small negative effect.

### Cross Validation

```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 4

H <- 20           
K <- 10          
n <- length(y)
rmse_auto <- c(); rmse_manual <- c()

for (i in 1:K) {
tr_end <- n - H*(K - i + 1)
if (tr_end < 250) break

y_tr <- y[1:tr_end]
y_te <- y[(tr_end+1):(tr_end+H)]
X_tr <- XS[1:tr_end, , drop=FALSE]
X_te <- XS[(tr_end+1):(tr_end+H), , drop=FALSE]

# auto

fit_a <- try(auto.arima(y_tr, xreg = X_tr, seasonal = FALSE), silent=TRUE)
if (!inherits(fit_a, "try-error")) {
fc_a <- forecast(fit_a, xreg = X_te, h = H)
rmse_auto <- c(rmse_auto, sqrt(mean((y_te - as.numeric(fc_a$mean))^2)))
}

# manual 

fit_m <- try(Arima(y_tr, order = ord, xreg = X_tr, include.mean = TRUE), silent=TRUE)
if (!inherits(fit_m, "try-error")) {
fc_m <- forecast(fit_m, xreg = X_te, h = H)
rmse_manual <- c(rmse_manual, sqrt(mean((y_te - as.numeric(fc_m$mean))^2)))
}
}

cv_df <- tibble(
Fold = 1:max(length(rmse_auto), length(rmse_manual)),
Auto  = rmse_auto,
Manual= rmse_manual
) |> pivot_longer(-Fold, names_to="Model", values_to="RMSE")

ggplot(na.omit(cv_df), aes(Fold, RMSE, color=Model)) +
geom_line() + geom_point(size=2) + theme_minimal() +
labs(title="BTC ARIMAX — Rolling CV RMSE", x="Fold", y="RMSE")

cat(sprintf("Mean RMSE → Auto: %.5f | Manual: %.5f\n",
mean(rmse_auto, na.rm=TRUE), mean(rmse_manual, na.rm=TRUE)))

best_is_auto <- mean(rmse_auto, na.rm=TRUE) <= mean(rmse_manual, na.rm=TRUE)
cat(sprintf("Chosen by CV: %s\n", ifelse(best_is_auto, "AUTO.ARIMA", "MANUAL ARIMAX")))

```

Rolling CV showed identical RMSE for Auto and Manual (0.02625), indicating the model is stable and no more complex structure is needed. AUTO.ARIMA was selected.

### Model Creation

```{r}
#| warning: false

best_model <- if (best_is_auto) m_btc_auto else m_btc_manual
cat("Final chosen model summary:\n"); print(summary(best_model))

# Diagnostics

resid_b <- residuals(best_model)
par(mfrow=c(1,2))
plot(resid_b, type="l", main="Residuals", ylab=NULL); abline(h=0, lty=2); grid()
acf(resid_b, main="Residual ACF"); grid()
par(mfrow=c(1,1))
lb <- Box.test(resid_b, lag = 20, type = "Ljung-Box")
cat(sprintf("Ljung-Box p (lag=20): %.4f\n", lb$p.value))

# Equation print 

co <- coef(best_model)
b_spx <- co[grep("SP500_ret", names(co))]
b_vix <- co[grep("VIX_ret", names(co))]
cat("\nRegression portion (on standardized xreg):\n")
cat(sprintf("BTC_ret_t = %.4f·SP500_ret_std_t %+ .4f·VIX_ret_std_t + ARMA errors\n",
ifelse(length(b_spx)==0, 0, b_spx),
ifelse(length(b_vix)==0, 0, b_vix)))

```

Final ARIMAX model:
BTC_ret = 0.0106·SP500_ret – 0.0014·VIX_ret + MA(1) errors
Residuals pass diagnostics (Ljung–Box p = 0.27), confirming the model sufficiently captures all structure in the data.

### Forecasting

```{r}
#| label: btc-forecast
#| warning: false
#| fig.width: 10
#| fig.height: 5

H <- 30



spx_fc <- forecast::forecast(auto.arima(returns$SP500_ret), h = H)$mean
vix_fc <- forecast::forecast(auto.arima(returns$VIX_ret),   h = H)$mean
Xfut   <- cbind(SP500_ret = as.numeric(spx_fc), VIX_ret = as.numeric(vix_fc))

# scale 

XfutS <- scale(Xfut,
center = attr(scale(as.matrix(returns[,c("SP500_ret","VIX_ret")])), "scaled:center"),
scale  = attr(scale(as.matrix(returns[,c("SP500_ret","VIX_ret")])), "scaled:scale"))

btc_ret_fc <- forecast(best_model, xreg = XfutS, h = H)

plot(btc_ret_fc, main="BTC Return Forecast — chosen ARIMAX"); grid()


last_lvl <- tail(price_data$Bitcoin, 1)
lvl_path <- last_lvl * exp(cumsum(as.numeric(btc_ret_fc$mean)))

# level-path plot

op <- par(mar=c(4,4,3,1))
plot(lvl_path, type="l", xlab="Forecast Step", ylab="BTC Level (approx.)",
main="BTC Level Path (from return forecasts)")
grid()
par(op)

cat(sprintf("Last observed BTC level: %.2f\n", last_lvl))
cat(sprintf("Forecasted BTC level at step %d: %.2f\n", H, tail(lvl_path,1)))

```

Return forecasts center near zero, as expected for financial returns. Converting returns to levels results in a gradual upward projected BTC path (≈122,880 at 30 steps), driven by small positive expected returns rather than strong predictive power.

:::

## S&P 500

::: {.panel-tabset}


### Visualization
```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 5
p1 <- ggplot(price_data, aes(Date, SP500)) +
geom_line() + theme_minimal() + labs(title="S&P 500 (Level)", x=NULL, y=NULL)
p2 <- ggplot(returns, aes(Date, SP500_ret)) +
geom_line() + theme_minimal() + labs(title="S&P 500 (Log-Returns)", x=NULL, y=NULL)
gridExtra::grid.arrange(p1, p2, nrow=2)

```

### Variable Selection
```{r}
#| warning: false
cm_spx <- cor(returns[, c("SP500_ret","Bitcoin_ret","VIX_ret")], use="complete.obs")
print(round(cm_spx, 3))
adf_spx <- tseries::adf.test(returns$SP500_ret)
adf_btc <- tseries::adf.test(returns$Bitcoin_ret)
adf_vix <- tseries::adf.test(returns$VIX_ret)
cat(sprintf("ADF p-values → SPX: %.4f | BTC: %.4f | VIX: %.4f\n",
adf_spx$p.value, adf_btc$p.value, adf_vix$p.value))

```

SPX returns show positive correlation with Bitcoin (0.28) and strong negative correlation with VIX (–0.73). All three return series are stationary (ADF p = 0.01), making BTC and VIX appropriate exogenous predictors.

### Initial Selection
```{r}
#| warning: false
y2   <- as.numeric(returns$SP500_ret)
X2   <- as.matrix(returns[, c("Bitcoin_ret","VIX_ret")])  # exog: BTC, VIX returns
X2S  <- scale(X2)

m_spx_auto <- forecast::auto.arima(y2, xreg = X2S, seasonal = FALSE)
cat("AUTO.ARIMA (SPX) summary:\n"); print(summary(m_spx_auto))

ols2 <- lm(y2 ~ X2S)
res2 <- resid(ols2)
res2_arima <- forecast::auto.arima(res2, seasonal = FALSE)
ord2 <- arimaorder(res2_arima)
m_spx_manual <- Arima(y2, order = ord2, xreg = X2S, include.mean = TRUE)
cat("\nMANUAL ARIMAX (SPX) summary:\n"); print(summary(m_spx_manual))

```

AUTO.ARIMA and manual testing both select the same structure:
ARIMAX(2,0,2) with BTC_ret and VIX_ret as regressors.
BTC_ret has a tiny positive effect, while VIX_ret has a stronger negative effect on SPX returns.

### Cross Validation

```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 4
H <- 20; K <- 10; n2 <- length(y2)
rmse_auto2 <- c(); rmse_manual2 <- c()

for (i in 1:K) {
tr_end <- n2 - H*(K - i + 1); if (tr_end < 250) break
y_tr <- y2[1:tr_end]; y_te <- y2[(tr_end+1):(tr_end+H)]
X_tr <- X2S[1:tr_end, , drop=FALSE]; X_te <- X2S[(tr_end+1):(tr_end+H), , drop=FALSE]
fa <- try(auto.arima(y_tr, xreg = X_tr, seasonal = FALSE), silent=TRUE)
if (!inherits(fa,"try-error")) {
fc <- forecast(fa, xreg = X_te, h = H)
rmse_auto2 <- c(rmse_auto2, sqrt(mean((y_te - as.numeric(fc$mean))^2)))
}
fm <- try(Arima(y_tr, order=ord2, xreg=X_tr, include.mean=TRUE), silent=TRUE)
if (!inherits(fm,"try-error")) {
fc <- forecast(fm, xreg = X_te, h = H)
rmse_manual2 <- c(rmse_manual2, sqrt(mean((y_te - as.numeric(fc$mean))^2)))
}
}
cv_spx <- tibble(Fold=1:max(length(rmse_auto2),length(rmse_manual2)),
Auto=rmse_auto2, Manual=rmse_manual2) |>
pivot_longer(-Fold, names_to="Model", values_to="RMSE")
ggplot(na.omit(cv_spx), aes(Fold, RMSE, color=Model)) +
geom_line() + geom_point(size=2) + theme_minimal() +
labs(title="SPX ARIMAX — Rolling CV RMSE")

cat(sprintf("Mean RMSE → Auto: %.5f | Manual: %.5f\n",
mean(rmse_auto2, na.rm=TRUE), mean(rmse_manual2, na.rm=TRUE)))
best_spx_is_auto <- mean(rmse_auto2, na.rm=TRUE) <= mean(rmse_manual2, na.rm=TRUE)
cat(sprintf("Chosen by CV: %s\n", ifelse(best_spx_is_auto,"AUTO.ARIMA","MANUAL ARIMAX")))

```

Rolling CV produced the same RMSE for Auto and Manual (0.00574), confirming the model is stable and AUTO.ARIMA is preferred.

### Model Creation
```{r}
#| warning: false
best_spx <- if (best_spx_is_auto) m_spx_auto else m_spx_manual
cat("Final SPX model summary:\n"); print(summary(best_spx))

resid_spx <- residuals(best_spx)
par(mfrow=c(1,2))
plot(resid_spx, type="l", main="SPX Residuals"); abline(h=0,lty=2); grid()
acf(resid_spx, main="Residual ACF"); grid()
par(mfrow=c(1,1))
lb2 <- Box.test(resid_spx, lag=20, type="Ljung-Box")
cat(sprintf("Ljung-Box p (lag=20): %.4f\n", lb2$p.value))

co2 <- coef(best_spx)
b_btc <- co2[grep("Bitcoin_ret", names(co2))]
b_vix <- co2[grep("VIX_ret", names(co2))]
cat("\nRegression portion (standardized xreg):\n")
cat(sprintf("SPX_ret_t = %.4f·BTC_ret_std_t %+ .4f·VIX_ret_std_t + ARMA errors\n",
ifelse(length(b_btc)==0,0,b_btc),
ifelse(length(b_vix)==0,0,b_vix)))

```

Final SPX ARIMAX model:
SPX_ret = 0.0014·BTC_ret – 0.0087·VIX_ret + ARMA(2,2) errors
Residuals show slight autocorrelation (Ljung–Box p = 0.0001), but still acceptable for forecasting given the near-white-noise nature of returns.

### Forecasting
```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 5
H <- 30

# Forecast BTC & VIX returns

btc_fc2 <- forecast::forecast(auto.arima(returns$Bitcoin_ret), h = H)$mean
vix_fc2 <- forecast::forecast(auto.arima(returns$VIX_ret),     h = H)$mean
Xfut2   <- cbind(Bitcoin_ret = as.numeric(btc_fc2), VIX_ret = as.numeric(vix_fc2))

Xfut2S <- scale(Xfut2,
center = attr(scale(as.matrix(returns[,c("Bitcoin_ret","VIX_ret")])), "scaled:center"),
scale  = attr(scale(as.matrix(returns[,c("Bitcoin_ret","VIX_ret")])), "scaled:scale"))

spx_ret_fc <- forecast(best_spx, xreg = Xfut2S, h = H)
plot(spx_ret_fc, main="SPX Return Forecast — chosen ARIMAX"); grid()

last_spx <- tail(price_data$SP500,1)
spx_level_path <- last_spx * exp(cumsum(as.numeric(spx_ret_fc$mean)))
plot(spx_level_path, type="l", xlab="Forecast Step", ylab="SPX Level (approx.)",
main="SPX Level Path (from return forecasts)"); grid()
cat(sprintf("Last SPX level: %.2f | Forecasted level @%d: %.2f\n",
last_spx, H, tail(spx_level_path,1)))

```

Return forecasts remain centered near zero, and the level projection shows mild upward drift (≈6694 at step 30), reflecting cumulative small positive expected returns rather than strong predictive signals.

:::

## VIX

::: {.panel-tabset}

### Visualization
```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 5
p1 <- ggplot(price_data, aes(Date, VIX)) +
geom_line() + theme_minimal() + labs(title="VIX (Level)", x=NULL, y=NULL)
p2 <- ggplot(returns, aes(Date, VIX_ret)) +
geom_line() + theme_minimal() + labs(title="VIX (Log-Returns)", x=NULL, y=NULL)
gridExtra::grid.arrange(p1, p2, nrow=2)


```



### Variable Selection
```{r}
#| warning: false
cm_vix <- cor(returns[, c("VIX_ret","Bitcoin_ret","SP500_ret")], use="complete.obs")
print(round(cm_vix, 3))
adf_vix <- tseries::adf.test(returns$VIX_ret)
adf_btc <- tseries::adf.test(returns$Bitcoin_ret)
adf_spx <- tseries::adf.test(returns$SP500_ret)
cat(sprintf("ADF p-values → VIX: %.4f | BTC: %.4f | SPX: %.4f\n",
adf_vix$p.value, adf_btc$p.value, adf_spx$p.value))

```

VIX is strongly negatively correlated with SP500 (–0.73) and mildly with BTC (–0.22).
Both included.



### Initial selection
```{r}
#| warning: false
y3   <- as.numeric(returns$VIX_ret)
X3   <- as.matrix(returns[, c("Bitcoin_ret","SP500_ret")])  # exog: BTC, SPX returns
X3S  <- scale(X3)

m_vix_auto <- forecast::auto.arima(y3, xreg = X3S, seasonal = FALSE)
cat("AUTO.ARIMA (VIX) summary:\n"); print(summary(m_vix_auto))

ols3 <- lm(y3 ~ X3S)
res3 <- resid(ols3)
res3_arima <- forecast::auto.arima(res3, seasonal = FALSE)
ord3 <- arimaorder(res3_arima)
m_vix_manual <- Arima(y3, order = ord3, xreg = X3S, include.mean = TRUE)
cat("\nMANUAL ARIMAX (VIX) summary:\n"); print(summary(m_vix_manual))

```

Series stationary (ADF p = 0.01).
AUTO.ARIMA selected ARIMA(3,0,4) errors.

### Cross Validation
```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 4
H <- 20; K <- 10; n3 <- length(y3)
rmse_auto3 <- c(); rmse_manual3 <- c()

for (i in 1:K) {
tr_end <- n3 - H*(K - i + 1); if (tr_end < 250) break
y_tr <- y3[1:tr_end]; y_te <- y3[(tr_end+1):(tr_end+H)]
X_tr <- X3S[1:tr_end, , drop=FALSE]; X_te <- X3S[(tr_end+1):(tr_end+H), , drop=FALSE]
fa <- try(auto.arima(y_tr, xreg = X_tr, seasonal = FALSE), silent=TRUE)
if (!inherits(fa,"try-error")) {
fc <- forecast(fa, xreg = X_te, h = H)
rmse_auto3 <- c(rmse_auto3, sqrt(mean((y_te - as.numeric(fc$mean))^2)))
}
fm <- try(Arima(y_tr, order=ord3, xreg=X_tr, include.mean=TRUE), silent=TRUE)
if (!inherits(fm,"try-error")) {
fc <- forecast(fm, xreg = X_te, h = H)
rmse_manual3 <- c(rmse_manual3, sqrt(mean((y_te - as.numeric(fc$mean))^2)))
}
}
cv_vix <- tibble(Fold=1:max(length(rmse_auto3),length(rmse_manual3)),
Auto=rmse_auto3, Manual=rmse_manual3) |>
pivot_longer(-Fold, names_to="Model", values_to="RMSE")
ggplot(na.omit(cv_vix), aes(Fold, RMSE, color=Model)) +
geom_line() + geom_point(size=2) + theme_minimal() +
labs(title="VIX ARIMAX — Rolling CV RMSE")

cat(sprintf("Mean RMSE → Auto: %.5f | Manual: %.5f\n",
mean(rmse_auto3, na.rm=TRUE), mean(rmse_manual3, na.rm=TRUE)))
best_vix_is_auto <- mean(rmse_auto3, na.rm=TRUE) <= mean(rmse_manual3, na.rm=TRUE)
cat(sprintf("Chosen by CV: %s\n", ifelse(best_vix_is_auto,"AUTO.ARIMA","MANUAL ARIMAX")))

```

Manual model slightly better (RMSE: 0.04936, vs Auto 0.04964) → Manual ARIMAX selected.


### Model Creation
```{r}
#| warning: false
best_vix <- if (best_vix_is_auto) m_vix_auto else m_vix_manual
cat("Final VIX model summary:\n"); print(summary(best_vix))

resid_vix <- residuals(best_vix)
par(mfrow=c(1,2))
plot(resid_vix, type="l", main="VIX Residuals"); abline(h=0,lty=2); grid()
acf(resid_vix, main="Residual ACF"); grid()
par(mfrow=c(1,1))
lb3 <- Box.test(resid_vix, lag=20, type="Ljung-Box")
cat(sprintf("Ljung-Box p (lag=20): %.4f\n", lb3$p.value))

co3 <- coef(best_vix)
b_btc3 <- co3[grep("Bitcoin_ret", names(co3))]
b_spx3 <- co3[grep("SP500_ret", names(co3))]
cat("\nRegression portion (standardized xreg):\n")
cat(sprintf("VIX_ret_t = %.4f·BTC_ret_std_t %+ .4f·SPX_ret_std_t + ARMA errors\n",
ifelse(length(b_btc3)==0,0,b_btc3),
ifelse(length(b_spx3)==0,0,b_spx3)))

```

VIX_ret = –0.0004·BTC_ret – 0.0587·SPX_ret + ARMA(3,4) errors.
SP500 has a sizable negative effect: when markets rise, VIX falls. BTC’s effect is negligible.

### Forecasting
```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 5
H <- 30

# Forecast  BTC & SPX returns

btc_fc3 <- forecast::forecast(auto.arima(returns$Bitcoin_ret), h = H)$mean
spx_fc3 <- forecast::forecast(auto.arima(returns$SP500_ret),  h = H)$mean
Xfut3   <- cbind(Bitcoin_ret = as.numeric(btc_fc3), SP500_ret = as.numeric(spx_fc3))

Xfut3S <- scale(Xfut3,
center = attr(scale(as.matrix(returns[,c("Bitcoin_ret","SP500_ret")])), "scaled:center"),
scale  = attr(scale(as.matrix(returns[,c("Bitcoin_ret","SP500_ret")])), "scaled:scale"))

vix_ret_fc <- forecast(best_vix, xreg = Xfut3S, h = H)
plot(vix_ret_fc, main="VIX Return Forecast — chosen ARIMAX"); grid()

last_vix <- tail(price_data$VIX,1)
vix_level_path <- last_vix * exp(cumsum(as.numeric(vix_ret_fc$mean)))
plot(vix_level_path, type="l", xlab="Forecast Step", ylab="VIX Level (approx.)",
main="VIX Level Path (from return forecasts)"); grid()
cat(sprintf("Last VIX level: %.2f | Forecasted level @%d: %.2f\n",
last_vix, H, tail(vix_level_path,1)))

```

VIX level path drifts gradually downward: ~15.70 → 15.02 over 30 days.

:::

## USD

::: {.panel-tabset}

### Visualization

```{r}
#| warning: false
p1 <- ggplot(price_data, aes(Date, USD)) +
  geom_line() + theme_minimal() +
  labs(title="USD (Level)", x=NULL, y=NULL)

p2 <- ggplot(returns, aes(Date, USD_ret)) +
  geom_line() + theme_minimal() +
  labs(title="USD (Log-Returns)", x=NULL, y=NULL)

gridExtra::grid.arrange(p1, p2, nrow=2)
```

### Variable Selection
```{r}
#| warning: false
cm_usd <- cor(
returns[, c("USD_ret","SP500_ret","VIX_ret","Bitcoin_ret")],
use="complete.obs"
)
print(round(cm_usd, 3))

adf_usd <- tseries::adf.test(returns$USD_ret)
cat(sprintf("ADF p-value → USD_ret: %.4f\n", adf_usd$p.value))
```

USD has only weak relationships with other assets: mild negative correlation with SPX (–0.31), mild positive with VIX (+0.22), and small negative with BTC (–0.17). No strong cross-asset linkages.

### Initial Selection

```{r}
#| warning: false

y_usd <- as.numeric(returns$USD_ret)
X_usd <- as.matrix(returns[, c("Bitcoin_ret","SP500_ret")])
X_usdS <- scale(X_usd)

# AUTO.ARIMA

m_usd_auto <- forecast::auto.arima(y_usd, xreg = X_usdS, seasonal = FALSE)
cat("AUTO.ARIMA (USD) summary:\n"); print(summary(m_usd_auto))

# Manual method

ols_usd <- lm(y_usd ~ X_usdS)
res_usd <- resid(ols_usd)
res_usd_arima <- forecast::auto.arima(res_usd, seasonal = FALSE)
ord_usd <- arimaorder(res_usd_arima)

m_usd_manual <- Arima(y_usd, order = ord_usd,
xreg = X_usdS, include.mean = TRUE)

cat("\nMANUAL ARIMAX (USD) summary:\n")
print(summary(m_usd_manual))

```

AUTO.ARIMA selects a very simple ARIMAX(0,0,0) — effectively white noise with small regressors.
Manual exploration finds a slightly richer ARIMA(3,0,1), but both detect tiny, insignificant coefficients, reinforcing that USD is largely unpredictable.

### Cross Validation

```{r}
#| warning: false
H <- 20; K <- 10
n_usd <- length(y_usd)
rmse_auto_usd <- c(); rmse_manual_usd <- c()

for (i in 1:K) {

tr_end <- n_usd - H*(K - i + 1)
if (tr_end < 250) break

y_tr <- y_usd[1:tr_end]
y_te <- y_usd[(tr_end+1):(tr_end+H)]

X_tr <- X_usdS[1:tr_end, , drop=FALSE]
X_te <- X_usdS[(tr_end+1):(tr_end+H), , drop=FALSE]

fit_a <- try(auto.arima(y_tr, xreg = X_tr, seasonal = FALSE), silent=TRUE)
if (!inherits(fit_a,"try-error")) {
fc <- forecast(fit_a, xreg = X_te, h = H)
rmse_auto_usd <- c(rmse_auto_usd,
sqrt(mean((y_te - as.numeric(fc$mean))^2)))
}

fit_m <- try(Arima(y_tr, order=ord_usd, xreg=X_tr, include.mean=TRUE),
silent=TRUE)
if (!inherits(fit_m,"try-error")) {
fc <- forecast(fit_m, xreg = X_te, h = H)
rmse_manual_usd <- c(rmse_manual_usd,
sqrt(mean((y_te - as.numeric(fc$mean))^2)))
}
}

cv_usd <- tibble(
Fold = 1:max(length(rmse_auto_usd),length(rmse_manual_usd)),
Auto = rmse_auto_usd,
Manual = rmse_manual_usd
) |> pivot_longer(-Fold, names_to="Model", values_to="RMSE")

ggplot(na.omit(cv_usd), aes(Fold, RMSE, color=Model)) +
geom_line() + geom_point(size=2) + theme_minimal() +
labs(title="USD ARIMAX — Rolling CV RMSE")

cat(sprintf("Mean RMSE → Auto: %.5f | Manual: %.5f\n",
mean(rmse_auto_usd, na.rm=TRUE),
mean(rmse_manual_usd, na.rm=TRUE)))

best_usd_is_auto <- mean(rmse_auto_usd, na.rm=TRUE) <=
mean(rmse_manual_usd, na.rm=TRUE)

cat(sprintf("Chosen by CV: %s\n",
ifelse(best_usd_is_auto,"AUTO.ARIMA","MANUAL ARIMAX")))
```
Rolling CV shows Auto and Manual models perform almost identically (RMSE ≈ 0.00328).
AUTO.ARIMA chosen, since added AR/MA structure brings no benefit.

### Model Creation

```{r}
#| warning: false
best_usd <- if (best_usd_is_auto) m_usd_auto else m_usd_manual
cat("Final USD model summary:\n"); print(summary(best_usd))

resid_usd <- residuals(best_usd)
par(mfrow=c(1,2))
plot(resid_usd, type="l", main="USD Residuals"); abline(h=0, lty=2); grid()
acf(resid_usd, main="Residual ACF"); grid()
par(mfrow=c(1,1))

lb_usd <- Box.test(resid_usd, lag=20, type="Ljung-Box")
cat(sprintf("Ljung-Box p (lag=20): %.4f\n", lb_usd$p.value))

co_usd <- coef(best_usd)
b_btc_usd <- co_usd[grep("Bitcoin_ret", names(co_usd))]
b_spx_usd <- co_usd[grep("SP500_ret", names(co_usd))]

cat("\nRegression portion (standardized xreg):\n")
cat(sprintf(
"USD_ret_t = %.4f·BTC_ret_std_t %+ .4f·SPX_ret_std_t + ARMA errors\n",
ifelse(length(b_btc_usd)==0,0,b_btc_usd),
ifelse(length(b_spx_usd)==0,0,b_spx_usd)
))

```

### Forecasting
```{r}
#| warning: false
H <- 30

# Forecast BTC & SPX returns as xreg

btc_fc_usd <- forecast::forecast(auto.arima(returns$Bitcoin_ret), h = H)$mean
spx_fc_usd <- forecast::forecast(auto.arima(returns$SP500_ret),  h = H)$mean

Xfut_usd <- cbind(Bitcoin_ret = as.numeric(btc_fc_usd),
SP500_ret   = as.numeric(spx_fc_usd))

X_train_usd <- as.matrix(returns[, c("Bitcoin_ret","SP500_ret")])

Xfut_usdS <- scale(
Xfut_usd,
center = attr(scale(X_train_usd),"scaled:center"),
scale  = attr(scale(X_train_usd),"scaled:scale")
)

usd_ret_fc <- forecast(best_usd, xreg = Xfut_usdS, h = H)
plot(usd_ret_fc, main="USD Return Forecast — chosen ARIMAX"); grid()

last_usd <- tail(price_data$USD,1)
usd_level_path <- last_usd * exp(cumsum(as.numeric(usd_ret_fc$mean)))

plot(usd_level_path, type="l",
main="USD Level Path (from return forecasts)",
xlab="Forecast Step", ylab="USD Index (approx.)")
grid()

cat(sprintf("Last USD level: %.2f\n", last_usd))
cat(sprintf("Forecasted USD level @%d: %.2f\n",
H, tail(usd_level_path,1)))

```

Final model:
USD_ret = –0.0003·BTC_ret – 0.0009·SPX_ret + white-noise errors.
Residuals pass all diagnostics, confirming near-pure randomness.
Forecasted returns hover around zero, and the level path remains flat (~120.10), indicating no momentum and no cross-asset predictability.

:::

## NASDAQ

::: {.panel-tabset}

### Visualization

```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 5

p1 <- ggplot(price_data, aes(Date, NASDAQ)) +
geom_line() + theme_minimal() +
labs(title="NASDAQ (Level)", x=NULL, y=NULL)

p2 <- ggplot(returns, aes(Date, NASDAQ_ret)) +
geom_line() + theme_minimal() +
labs(title="NASDAQ (Log-Returns)", x=NULL, y=NULL)

gridExtra::grid.arrange(p1, p2, nrow=2)

```


### Variable Selection
```{r}
#| warning: false

# Check correlations

cm_nas <- cor(returns[, c("NASDAQ_ret","SP500_ret","VIX_ret","Bitcoin_ret")],
use="complete.obs")
print(round(cm_nas, 3))

# Stationarity tests

adf_nas <- adf.test(returns$NASDAQ_ret)
adf_spx <- adf.test(returns$SP500_ret)
adf_vix <- adf.test(returns$VIX_ret)

cat(sprintf("ADF p-values → NASDAQ: %.4f | SPX: %.4f | VIX: %.4f\n",
adf_nas$p.value, adf_spx$p.value, adf_vix$p.value))

```

NASDAQ is linked to SP500 (ρ = 0.95) and strongly negatively correlated with VIX (fear) at –0.72. Bitcoin has only a mild positive relationship. All series are stationary in returns (ADF p = 0.01), so SP500_ret and VIX_ret are included as meaningful predictors.


### Initial Selection

```{r}
#| warning: false

# Target: NASDAQ returns

y_nas <- as.numeric(returns$NASDAQ_ret)

# Exogenous regressors: SP500 + VIX 

X_nas <- as.matrix(returns[, c("SP500_ret","VIX_ret")])
X_nasS <- scale(X_nas)

# AUTO.ARIMA 

m_nas_auto <- forecast::auto.arima(y_nas, xreg = X_nasS, seasonal = FALSE)
cat("AUTO.ARIMA (NASDAQ) summary:\n"); print(summary(m_nas_auto))

# Manual ARIMAX

ols_nas <- lm(y_nas ~ X_nasS)
res_nas <- resid(ols_nas)
res_nas_arima <- forecast::auto.arima(res_nas, seasonal = FALSE)
ord_nas <- arimaorder(res_nas_arima)

m_nas_manual <- Arima(y_nas, order = ord_nas,
xreg = X_nasS, include.mean = TRUE)

cat("\nMANUAL ARIMAX (NASDAQ) summary:\n")
print(summary(m_nas_manual))


```

AUTO.ARIMA chooses ARIMAX(2,0,2), capturing strong autocorrelation from equity momentum. Coefficients show NASDAQ rises with SPX (≈ 0.0141) and falls when VIX increases (≈ –0.0008), matching market intuition. Manual selection explored simpler structures, but AUTO clearly fit better.

### Cross Validation

```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 4

H <- 20
K <- 10
n_nas <- length(y_nas)

rmse_auto_nas <- c()
rmse_manual_nas <- c()

for (i in 1:K) {
tr_end <- n_nas - H*(K - i + 1)
if (tr_end < 250) break

y_tr <- y_nas[1:tr_end]
y_te <- y_nas[(tr_end+1):(tr_end+H)]

X_tr <- X_nasS[1:tr_end, , drop=FALSE]
X_te <- X_nasS[(tr_end+1):(tr_end+H), , drop=FALSE]

# AUTO.ARIMA

fit_a <- try(auto.arima(y_tr, xreg = X_tr, seasonal = FALSE), silent=TRUE)
if (!inherits(fit_a, "try-error")) {
fc <- forecast(fit_a, xreg = X_te, h = H)
rmse_auto_nas <- c(rmse_auto_nas,
sqrt(mean((y_te - as.numeric(fc$mean))^2)))
}

# MANUAL ARIMAX

fit_m <- try(Arima(y_tr, order=ord_nas, xreg=X_tr, include.mean=TRUE),
silent=TRUE)
if (!inherits(fit_m, "try-error")) {
fc <- forecast(fit_m, xreg = X_te, h = H)
rmse_manual_nas <- c(rmse_manual_nas,
sqrt(mean((y_te - as.numeric(fc$mean))^2)))
}
}

cv_nas <- tibble(
Fold  = 1:max(length(rmse_auto_nas), length(rmse_manual_nas)),
Auto  = rmse_auto_nas,
Manual= rmse_manual_nas
) |> pivot_longer(-Fold, names_to="Model", values_to="RMSE")

ggplot(na.omit(cv_nas), aes(Fold, RMSE, color=Model)) +
geom_line() + geom_point(size=2) +
theme_minimal() +
labs(title="NASDAQ ARIMAX — Rolling CV RMSE",
x="Fold", y="RMSE")

cat(sprintf("Mean RMSE → Auto: %.5f | Manual: %.5f\n",
mean(rmse_auto_nas,   na.rm=TRUE),
mean(rmse_manual_nas, na.rm=TRUE)))

best_nas_is_auto <- mean(rmse_auto_nas, na.rm=TRUE) <=
mean(rmse_manual_nas, na.rm=TRUE)

cat(sprintf("Chosen by CV: %s\n",
ifelse(best_nas_is_auto, "AUTO.ARIMA", "MANUAL ARIMAX")))


```


Rolling CV shows nearly identical errors for Auto vs Manual (RMSE ≈ 0.00377).
AUTO.ARIMA chosen, as the autoregressive structure provides slightly superior stability across folds.

### Model Creation

```{r}
#| warning: false

best_nas <- if (best_nas_is_auto) m_nas_auto else m_nas_manual

cat("Final NASDAQ model summary:\n"); print(summary(best_nas))

resid_nas <- residuals(best_nas)

par(mfrow=c(1,2))
plot(resid_nas, type="l", main="NASDAQ Residuals"); abline(h=0,lty=2); grid()
acf(resid_nas, main="Residual ACF"); grid()
par(mfrow=c(1,1))

lb_nas <- Box.test(resid_nas, lag=20, type="Ljung-Box")
cat(sprintf("Ljung-Box p (lag=20): %.4f\n", lb_nas$p.value))

co_nas <- coef(best_nas)
b_spx_nas <- co_nas[grep("SP500_ret", names(co_nas))]
b_vix_nas <- co_nas[grep("VIX_ret",    names(co_nas))]

cat("\nRegression portion (standardized xreg):\n")
cat(sprintf(
"NASDAQ_ret_t = %.4f·SP500_ret_std_t %+ .4f·VIX_ret_std_t + ARMA errors\n",
ifelse(length(b_spx_nas)==0,0,b_spx_nas),
ifelse(length(b_vix_nas)==0,0,b_vix_nas)
))


```

Final model confirms the relationships: NASDAQ_ret increases with SPX_ret and decreases with VIX_ret, while AR/MA terms capture market persistence. Residuals pass diagnostics (Ljung–Box p = 0.48).

### Forecasting
```{r}
#| warning: false
#| fig.width: 10
#| fig.height: 5

H <- 30

# Forecast SPX & VIX returns

spx_fc_nas <- forecast::forecast(auto.arima(returns$SP500_ret), h = H)$mean
vix_fc_nas <- forecast::forecast(auto.arima(returns$VIX_ret),   h = H)$mean

Xfut_nas <- cbind(
SP500_ret = as.numeric(spx_fc_nas),
VIX_ret   = as.numeric(vix_fc_nas)
)

Xfut_nasS <- scale(
Xfut_nas,
center = attr(scale(as.matrix(returns[,c("SP500_ret","VIX_ret")])),
"scaled:center"),
scale  = attr(scale(as.matrix(returns[,c("SP500_ret","VIX_ret")])),
"scaled:scale")
)

nas_ret_fc <- forecast(best_nas, xreg = Xfut_nasS, h = H)

plot(nas_ret_fc, main="NASDAQ Return Forecast — chosen ARIMAX"); grid()

# Convert to level path

last_nas <- tail(price_data$NASDAQ,1)
nas_level_path <- last_nas * exp(cumsum(as.numeric(nas_ret_fc$mean)))

plot(nas_level_path, type="l",
xlab="Forecast Step", ylab="NASDAQ Level (approx.)",
main="NASDAQ Level Path (from return forecasts)")
grid()

cat(sprintf("Last NASDAQ level: %.2f\n", last_nas))
cat(sprintf("Forecasted NASDAQ level @%d: %.2f\n",
H, tail(nas_level_path,1)))


```

Forecasts show small positive returns accumulating into a modest upward trend, taking levels from ~22,470 to ~22,937 after 30 steps.

:::

The multivariate analysis reveals a clear hierarchy of cross-market influence. Equities (S&P 500, NASDAQ) are highly interconnected (ρ ≈ 0.95) and strongly driven by VIX, whose coefficients are consistently the largest and most significant. Rising volatility reliably predicts falling equity returns, and the ARIMAX models capture this relationship cleanly.

VIX, in contrast, behaves almost entirely as an autoregressive process, showing minimal responsiveness to equities or Bitcoin, reinforcing its role as an independent risk barometer.

Bitcoin remains largely isolated. Correlations are low, cross-effects are weak, and no traditional asset provides meaningful predictive power. Its movement is dominated by its own AR/MA dynamics rather than macro or equity variables.

USD shows essentially no interaction with the system: coefficients are near zero, correlations are tiny, and ARIMAX models confirm it behaves as an independent, noise-like process at the daily level.

Overall, the multivariate system shows that VIX anchors equity behavior, equities move together, while Bitcoin and USD operate mostly outside this network, offering diversification but limited short-run predictability.

