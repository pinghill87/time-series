---
title: "Univariate TS Models (ARIMA/SARIMA)"
code-fold: true
execute:
  cache: true
  freeze: auto
---

## Model Setup

We load daily data for Bitcoin, S&P 500, NASDAQ, VIX, and the USD Index from FRED and merge the valid series into a single cleaned dataset. Returns are computed using first-differenced log prices.

::: {.panel-tabset}

### Data Preparation
```{r}
#| warning: false
#| message: false

library(quantmod)
library(tidyverse)
library(zoo)
library(forecast)
library(tseries)

start_date <- as.Date("2019-01-01")
end_date   <- as.Date("2025-09-18")

load_fred_data <- function(symbol) {
  tryCatch(
    getSymbols(symbol, src = "FRED", from = start_date, to = end_date,
               auto.assign = FALSE),
    error = function(e) { cat("FAILED:", symbol, "\n"); NULL }
  )
}

sp500_data  <- load_fred_data("SP500")
vix_data    <- load_fred_data("VIXCLS")
btc_data    <- load_fred_data("CBBTCUSD")
nasdaq_data <- load_fred_data("NASDAQCOM")
usd_data    <- load_fred_data("DTWEXBGS")

merge_list <- list(
  SP500   = sp500_data,
  VIX     = vix_data,
  Bitcoin = btc_data,
  NASDAQ  = nasdaq_data,
  USD     = usd_data
)
merge_list <- merge_list[!sapply(merge_list, is.null)]

price_zoo  <- do.call(merge.zoo, merge_list)
price_data <- fortify.zoo(price_zoo)
colnames(price_data) <- c("Date", names(merge_list))
price_data <- price_data |> na.omit()

get_series <- function(asset) price_data[[asset]]
get_diff_series <- function(asset) diff(log(price_data[[asset]])) |> na.omit()




cat(
  "\n=== DATASET SUMMARY ===\n",
  "Observations : ", nrow(price_data), "\n",
  "Assets Loaded: ", length(merge_list), "\n",
  "Date Range   : ", min(price_data$Date), " to ", max(price_data$Date), "\n"
)


```

```{r}
#| warning: false
#| message: false


assets <- names(merge_list)

arima_models <- list()
sarima_models <- list()

for (a in assets) {
series <- get_diff_series(a)

arima_models[[a]] <- auto.arima(series, stepwise=TRUE, approximation=TRUE)

sarima_models[[a]] <- auto.arima(series, seasonal=TRUE,
stepwise=TRUE, approximation=TRUE)
}


```



For modeling, each asset is fit with an ARIMA/SARIMA model using auto.arima() for efficient order selection. Models are stored once and reused throughout the page for diagnostics, ACF/PACF inspection, forecasting, and benchmark comparisons. 

### Helper Functions

```{r}
#| warning: false
#| message: false

plot_original_and_diff <- function(asset) {
  
  # Extract series
  original <- price_data[[asset]]
  dates    <- price_data$Date
  diff_ser <- get_diff_series(asset)
  
  # Layout
  par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))
  
  # --- Original price plot ---
  plot(dates, original, type = "l", col = "steelblue",
       main = paste(asset, "- Original Series"),
       xlab = "Date", ylab = "Price Level")
  
  # --- First difference plot (log returns) ---
  plot(diff_ser, type = "l", col = "red",
       main = paste(asset, "- Log Returns (First Difference)"),
       xlab = "Index", ylab = "Log Return")
  
  # Reset layout
  par(mfrow = c(1, 1))
}


run_stationarity <- function(asset) {
print(adf.test(get_diff_series(asset)))
}

plot_acf_pacf <- function(asset) {
series <- get_diff_series(asset)
par(mfrow=c(1,2))
acf(series, main=paste(asset,"ACF"))
pacf(series, main=paste(asset,"PACF"))
par(mfrow=c(1,1))
}

run_arima_models <- function(asset) {
print(arima_models[[asset]])
}

run_arima_diagnostics <- function(asset) {
tsdiag(arima_models[[asset]])
}

forecast_arima_asset <- function(asset) {
plot(forecast(arima_models[[asset]], h=30),
main=paste(asset,"ARIMA Forecast"))
}

compare_benchmarks <- function(asset) {

  s <- get_diff_series(asset)

  f_naive  <- naive(s, h = 30)
  f_snaive <- snaive(s, h = 30)
  f_arima  <- forecast(arima_models[[asset]], h = 30)

  results <- tibble(
    Model = c("Naive", "Seasonal Naive", "ARIMA"),
    RMSE  = c(accuracy(f_naive)[,"RMSE"],
              accuracy(f_snaive)[,"RMSE"],
              accuracy(f_arima)[,"RMSE"]),
    MAE   = c(accuracy(f_naive)[,"MAE"],
              accuracy(f_snaive)[,"MAE"],
              accuracy(f_arima)[,"MAE"]),
    MAPE  = c(accuracy(f_naive)[,"MAPE"],
              accuracy(f_snaive)[,"MAPE"],
              accuracy(f_arima)[,"MAPE"])
  )

  print(results)

  # --------------------------------------------------------------
  # FIX: Extract safely and guarantee numeric, not NA, not ts
  # --------------------------------------------------------------
  arima_rmse <- suppressWarnings(as.numeric(results$RMSE[results$Model == "ARIMA"]))
  best_bench <- suppressWarnings(as.numeric(min(results$RMSE[results$Model != "ARIMA"], na.rm = TRUE)))

  # If still NA, replace with Inf so comparison will work
  if (is.na(arima_rmse)) arima_rmse <- Inf
  if (is.na(best_bench)) best_bench <- Inf

  pct_diff <- 100 * (best_bench - arima_rmse) / best_bench

  # --------------------------------------------------------------
  # Interpretation
  # --------------------------------------------------------------
  cat("\nInterpretation for", asset, "\n")

  if (isTRUE(arima_rmse < best_bench)) {

    cat(
      "ARIMA outperforms the benchmark models.\n",
      "It improves RMSE by", round(pct_diff, 2), "% relative to the best naive model.\n"
    )

  } else if (isTRUE(arima_rmse > best_bench)) {

    cat(
      "ARIMA does NOT beat the benchmarks.\n",
      "It performs", round(-pct_diff, 2), "% worse than the best naive model.\n"
    )

  } else {

    cat("ARIMA performs similarly to the naive benchmarks.\n")

  }

  invisible(results)
}



run_sarima_models <- function(asset) {
print(sarima_models[[asset]])
}

forecast_sarima_asset <- function(asset) {
plot(forecast(sarima_models[[asset]], h=30),
main=paste(asset,"SARIMA Forecast"))
}

seasonality_analysis <- function(asset) {
s <- ts(get_diff_series(asset), frequency=365)
plot(stl(s, "periodic"), main=paste(asset,"Seasonality"))
}

# FAST CV — no repeated auto.arima calls

cross_validate_sarima <- function(asset) {
series <- ts(get_diff_series(asset))
model <- sarima_models[[asset]]
ffun <- function(y, h) forecast(model, h=h)
e <- tsCV(series, ffun, h=1)
mean(e^2, na.rm=TRUE)
}

```

What These Helper Functions Do

The following helper functions streamline the ARIMA/SARIMA workflow by wrapping common analysis steps into reusable tools:

- **`plot_original_and_diff()`**  
  Plots the raw price series and its first-differenced log returns to visualize stationarity and volatility changes.

- **`run_stationarity()`**  
  Runs the Augmented Dickey–Fuller (ADF) test on the differenced series to confirm stationarity before modeling.

- **`plot_acf_pacf()`**  
  Produces ACF and PACF plots of the return series, helping identify potential ARIMA orders.

- **`run_arima_models()`**  
  Prints the fitted ARIMA model for a selected asset.

- **`run_arima_diagnostics()`**  
  Displays residual diagnostics for the ARIMA model (autocorrelation, Ljung–Box tests).

- **`forecast_arima_asset()`**  
  Generates a 30-day ARIMA forecast with confidence intervals.

- **`compare_benchmarks()`**  
  Compares ARIMA forecasts to simple alternatives: Naive and Seasonal Naive models.

- **`run_sarima_models()`**  
  Prints the asset’s fitted SARIMA model (seasonal version).

- **`forecast_sarima_asset()`**  
  Produces a 30-day SARIMA forecast for comparison with ARIMA.

- **`seasonality_analysis()`**  
  Performs STL decomposition to examine seasonal effects in the differenced series.

- **`cross_validate_sarima()`**  
  Performs fast one-step-ahead cross-validation using a fixed SARIMA model (no repeated auto.arima calls).

Together, these utilities enable fast inspection, diagnostics, and forecasting for all assets without rewriting code for each analysis.


:::

## Univariate Time Series Analysis

### Bitcoin

::: {.panel-tabset}

#### 1. Overview & Stationarity
```{r}
#| warning: false
#| message: false
#| 
plot_original_and_diff("Bitcoin")

run_stationarity("Bitcoin")


plot_acf_pacf("Bitcoin")
```
Bitcoin prices are non-stationary, but the log returns become stationary after differencing, with very little autocorrelation.

#### 2. ARIMA
```{r}
#| warning: false
#| message: false

run_arima_models("Bitcoin")



run_arima_diagnostics("Bitcoin")



forecast_arima_asset("Bitcoin")
```
ARIMA selects a simple MA(2)-type model, and diagnostics show clean, white-noise residuals with no remaining structure.

#### 3. SARIMA & Seasonality
```{r}
#| warning: false
#| message: false

run_sarima_models("Bitcoin")



forecast_sarima_asset("Bitcoin")






seasonality_analysis("Bitcoin")
```

SARIMA collapses to the same model because Bitcoin returns show no meaningful seasonality in the STL decomposition.

#### 4. Benchmarks & Cross-Validation
```{r}
#| results: 'markup'
#| echo: false
#| message: false
#| warning: false


compare_benchmarks("Bitcoin")

```

```{r}
#| warning: false
cv_btc <- cross_validate_sarima("Bitcoin")

cat(
  "SARIMA Cross-Validation (Bitcoin)\n",
  "RMSE:", format(round(cv_btc, 6), nsmall = 6), "\n"
)

```

ARIMA beats both naïve benchmarks with a 31% lower RMSE, and SARIMA cross-validation shows a very small error (≈0.0017), confirming minimal but detectable short-term predictability.

:::



### S&P 500

::: {.panel-tabset}

#### 1. Overview & Stationarity
```{r}
#| warning: false
#| message: false

plot_original_and_diff("SP500")



run_stationarity("SP500")





plot_acf_pacf("SP500")
```

The S&P 500 price series is non-stationary, but its log returns become stationary with very weak autocorrelation.

#### 2. ARIMA
```{r}
#| warning: false
#| message: false

run_arima_models("SP500")





run_arima_diagnostics("SP500")


forecast_arima_asset("SP500")
```

The selected ARIMA(2,0,2) captures small short-run dynamics, and residual diagnostics show clean, white-noise behavior with no remaining structure.


#### 3. SARIMA & Seasonality
```{r}
#| warning: false
#| message: false

run_sarima_models("SP500")



forecast_sarima_asset("SP500")



seasonality_analysis("SP500")
```
SARIMA reduces to the same ARMA-type model, as S&P 500 returns show no meaningful seasonality in the STL decomposition.

#### Benchmarks & Cross-Validation
```{r}
#| results: 'markup'
#| echo: false
#| message: false
#| warning: false

compare_benchmarks("SP500")
```

```{r}
#| warning: false
cv_spx <- cross_validate_sarima("SP500")

cat(
  " SARIMA Cross-Validation (S&P 500)\n",
  "RMSE:", format(round(cv_spx, 6), nsmall = 6), "\n"
)

```

ARIMA meaningfully improves forecast accuracy—37% lower RMSE than the naïve models—and SARIMA cross-validation shows very low one-step error (≈0.00017), confirming only slight but detectable predictability in equity returns.
:::

### NASDAQ
::: {.panel-tabset}

#### 1. Overview & Stationarity
```{r}
#| warning: false
#| message: false

plot_original_and_diff("NASDAQ")



run_stationarity("NASDAQ")



plot_acf_pacf("NASDAQ")
```

NASDAQ prices are non-stationary, but the log returns are stationary with very weak autocorrelation, similar to other equity indexes.

#### 2. ARIMA
```{r}
#| warning: false
#| message: false


run_arima_models("NASDAQ")



run_arima_diagnostics("NASDAQ")

#| warning: false
#| message: false

forecast_arima_asset("NASDAQ")
```

The selected ARIMA(4,0,3) captures slight short-run dependencies, and the residuals are clean and white-noise-like, indicating a well-specified model.

#### 3. SARIMA & Seasonality
```{r}
#| warning: false
#| message: false

run_sarima_models("NASDAQ")


forecast_sarima_asset("NASDAQ")



seasonality_analysis("NASDAQ")
```

SARIMA collapses to the same structure because NASDAQ returns show no meaningful seasonal pattern in the STL decomposition.

#### Benchmarks & Cross-Validation
```{r}
#| results: 'markup'
#| echo: false
#| message: false
#| warning: false
#| 
compare_benchmarks("NASDAQ")
```
```{r}
#| warning: false
cv_nasdaq <- cross_validate_sarima("NASDAQ")

cat(
  "SARIMA Cross-Validation (NASDAQ)\n",
  "RMSE:", format(round(cv_nasdaq, 6), nsmall = 6), "\n"
)

```

ARIMA improves RMSE by 35% compared to the naïve models, and SARIMA cross-validation shows a very small error (~0.00024), suggesting only mild but detectable short-term predictability.
:::


### VIX
::: {.panel-tabset}

#### 1. Time Series + First Difference
```{r}
#| warning: false
#| message: false

plot_original_and_diff("VIX")



run_stationarity("VIX")


plot_acf_pacf("VIX")
```

VIX prices are highly volatile and non-stationary, but the log returns are stationary with noticeable volatility bursts typical of risk-sentiment measures.

#### 2. ARIMA
```{r}
#| warning: false
#| message: false

run_arima_models("VIX")

run_arima_diagnostics("VIX")


forecast_arima_asset("VIX")
```

The fitted ARIMA(3,0,1) captures modest short-run persistence in volatility spikes, and residual diagnostics show a good fit with mostly white-noise residuals.



#### 3. SARIMA & Seasonality
```{r}
#| warning: false
#| message: false
run_sarima_models("VIX")

#| warning: false
#| message: false
forecast_sarima_asset("VIX")

#| warning: false
#| message: false
seasonality_analysis("VIX")
```

SARIMA reduces to the same structure because VIX returns show no meaningful seasonality, only irregular volatility cycles.

#### Benchmarks & Cross-Validation
```{r}
#| results: 'markup'
#| echo: false
#| message: false
#| warning: false

compare_benchmarks("VIX")
```
```{r}
#| warning: false
cv_vix <- cross_validate_sarima("VIX")

cat(
  " SARIMA Cross-Validation (VIX)\n",
  "RMSE:", format(round(cv_vix, 6), nsmall = 6), "\n"
)


```

ARIMA improves RMSE by 33% relative to naïve forecasts, and SARIMA cross-validation RMSE (~0.0063) confirms limited but non-zero predictability in short-term VIX movements.

:::


### USD
::: {.panel-tabset}

#### 1. Time Series + First Difference
```{r}
#| warning: false
#| message: false
plot_original_and_diff("USD")

#| warning: false
#| message: false
run_stationarity("USD")

#| warning: false
#| message: false
plot_acf_pacf("USD")
```

USD prices are non-stationary, but the log returns are stationary and show almost no autocorrelation, indicating very weak short-run structure.

#### 2. ARIMA
```{r}
#| warning: false
#| message: false
run_arima_models("USD")

#| warning: false
#| message: false
run_arima_diagnostics("USD")

#| warning: false
#| message: false
forecast_arima_asset("USD")
```

The model collapses to a simple ARIMA(0,0,1), reflecting near-white-noise behavior, and residuals confirm a clean, structureless fit.


#### 3. SARIMA & Seasonality
```{r}
#| warning: false
#| message: false
run_sarima_models("USD")


forecast_sarima_asset("USD")


seasonality_analysis("USD")
```

SARIMA produces the same model because USD returns exhibit no meaningful seasonality, only small random fluctuations.

#### 4. Benchmarks & Cross-Validation
```{r}
#| results: 'markup'
#| echo: false
#| message: false
#| warning: false

compare_benchmarks("USD")
```
```{r}
#| warning: false
cv_usd <- cross_validate_sarima("USD")

cat(
  "SARIMA Cross-Validation (USD)\n",
  "RMSE:", format(round(cv_usd, 6), nsmall = 6), "\n"
)


```

ARIMA improves RMSE by ~28% over naïve forecasts, though the overall errors are extremely small; SARIMA cross-validation RMSE (~1e-05) confirms that USD returns contain almost no predictable component.

:::

## Results and Insights

Across Bitcoin, the S&P 500, NASDAQ, VIX, and the USD Index, price levels are non-stationary while daily log returns are stationary with minimal autocorrelation—consistent with the stylized fact that financial returns behave like near–white noise.

ARIMA models pick up only small, short-lived dynamics: simple MA(1)/MA(2) or low-order ARMA structures for most assets, with NASDAQ fitting a higher-order ARIMA(4,0,3). These models slightly outperform naïve forecasts but provide only marginal predictive power. SARIMA adds no benefit, confirming that daily financial returns do not contain meaningful seasonal patterns.

Equity indexes (SP500, NASDAQ) show modest autoregressive structure, VIX displays short-run mean reversion, and Bitcoin and USD behave closest to pure noise. Even so, predictive improvements remain limited and forecasts quickly revert toward zero.

Overall, univariate ARIMA models help characterize return behavior but cannot meaningfully forecast price movements. Financial markets remain highly efficient at the daily horizon, leaving only tiny pockets of short-term predictability.

