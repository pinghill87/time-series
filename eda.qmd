---
title: "Exploratory Data Analysis"
author: "Financial Time Series Analysis"
date: today
format:
  html:
    code-fold: true
    toc: true
    toc-depth: 3
    theme: cosmo
---

## Data Preparation

::: {.panel-tabset}

### Data Loading
```{r setup}
#| warning: false
#| message: false
#| echo: false

# ==============================================================================
# EXPLORATORY DATA ANALYSIS (EDA) - R VERSION
# Bitcoin, S&P 500, and VIX — per-asset sections with tabsets
# ==============================================================================

required_packages <- c(
  "tidyverse","quantmod","tseries","forecast","ggplot2",
  "gridExtra","scales","lubridate","zoo","PerformanceAnalytics"
)
new_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if (length(new_packages)) install.packages(new_packages, quiet = TRUE)

suppressPackageStartupMessages({
  library(tidyverse); library(quantmod); library(tseries); library(forecast)
  library(ggplot2);   library(gridExtra); library(scales);  library(lubridate)
  library(zoo);       library(PerformanceAnalytics)
})

```


```{r}
#| warning: false
#| message: false

#| warning: false
#| message: false


start_date <- as.Date("2019-01-01")
end_date   <- as.Date("2025-09-18")

load_fred_data <- function(symbol, start, end) {
  tryCatch({
    getSymbols(symbol, src = "FRED", from = start, to = end, auto.assign = FALSE)
  }, error = function(e) { 
    cat(sprintf("Warning: Could not load %s\n", symbol)); 
    NULL 
  })
}

# ---- Load Core Data ----
sp500_data   <- load_fred_data("SP500",       start_date, end_date)
vix_data     <- load_fred_data("VIXCLS",      start_date, end_date)
btc_data     <- load_fred_data("CBBTCUSD",    start_date, end_date)
nasdaq_data  <- load_fred_data("NASDAQCOM",   start_date, end_date)  
usd_data     <- load_fred_data("DTWEXBGS",         start_date, end_date)   # USD Index (Broad Dollar Index)

# ---- Merge All ----
price_data <- merge.zoo(
  SP500    = sp500_data,
  VIX      = vix_data,
  Bitcoin  = btc_data,
  NASDAQ   = nasdaq_data,
  USD      = usd_data
)

price_data <- fortify.zoo(price_data)
colnames(price_data) <- c("Date","SP500","VIX","Bitcoin","NASDAQ","USD")
price_data <- price_data |> na.omit()

cat(sprintf("Data loaded: %d observations, %d variables\n", 
            nrow(price_data), ncol(price_data)-1))

# ---- Returns ----
returns <- price_data |>
  arrange(Date) |>
  mutate(
    SP500_ret   = c(NA, diff(log(SP500))),
    VIX_ret     = c(NA, diff(log(VIX))),
    Bitcoin_ret = c(NA, diff(log(Bitcoin))),
    NASDAQ_ret  = c(NA, diff(log(NASDAQ))),
    USD_ret     = c(NA, diff(log(USD)))
  ) |>
  na.omit()



```


We collect daily financial data from **2019–2025** for five key market variables:  
**Bitcoin**, **S&P 500**, **NASDAQ Composite**, **VIX**, and the **USD Index**.  
All series are pulled directly from the Federal Reserve Economic Data (FRED) API.

After loading the data, we merge the five time series into a single dataset with a shared date index and remove any missing observations. The final dataset contains:

- **`r nrow(price_data)` observations**  
- **5 financial variables** (SP500, VIX, Bitcoin, NASDAQ, USD)  
- **Daily frequency**  

This provides a clean foundation for exploratory analysis and later forecasting tasks.

### Return Calculations

Because raw price levels are non-stationary, we compute **log returns** for each asset:

\[
r_t = \log(P_t) - \log(P_{t-1})
\]

This transformation stabilizes variance, removes long-term trends, and makes the series suitable for correlation, volatility, and deep learning modeling. After computing log returns and removing the initial missing row, our returns dataset contains:

- **`r nrow(returns)` observations**  
- **5 return variables** (SP500_ret, VIX_ret, Bitcoin_ret, NASDAQ_ret, USD_ret)

These prepared return series form the basis for all subsequent EDA, ARIMA modeling, and deep learning models used later in the project.

:::

```{r}
#| warning: false
#| message: false
#| echo: false

# ===== Helper functions (reuse across assets) =====

plot_ts_with_trend <- function(asset) {
stopifnot(asset %in% colnames(price_data))
df <- price_data |> dplyr::select(Date, dplyr::all_of(asset)) |> tidyr::drop_na()
x  <- seq_len(nrow(df))
df$trend <- predict(lm(df[[asset]] ~ x))

ggplot(df, aes(x = Date)) +
geom_line(aes(y = .data[[asset]], color = "Actual"), linewidth = 0.8, alpha = 0.85) +
geom_line(aes(y = trend, color = "Trend"), linewidth = 1.1, linetype = "dashed") +
scale_color_manual(values = c("Actual" = "steelblue", "Trend" = "red")) +
labs(title = paste(asset, "- Original Time Series"), x = "Date", y = "Price/Level", color = "") +
theme_minimal() + theme(legend.position = "bottom", plot.title = element_text(face = "bold"))
}

component_analysis_print <- function(asset) {
vals <- stats::na.omit(price_data[[asset]])
x    <- seq_along(vals)
trend_slope <- coef(lm(vals ~ x))[2]
cv   <- stats::sd(vals)/mean(vals)
cat(sprintf("• Trend: %s (slope: %.4f)\n", ifelse(trend_slope>0,"Upward","Downward"), trend_slope))
cat(sprintf("• Variation (CV): %.3f\n", cv))
cat(sprintf("• Range: %.2f to %.2f\n", min(vals), max(vals)))
if (length(vals) > 100) {
high <- vals[vals > median(vals)]; low <- vals[vals <= median(vals)]
var_ratio <- var(high)/var(low); seasonality <- ifelse(var_ratio>2,"Multiplicative","Additive")
cat(sprintf("• Seasonality Type: %s (variance ratio: %.2f)\n", seasonality, var_ratio))
}
}

create_lag_plots <- function(asset, lags = c(1,7,30)) {
values <- price_data[[asset]]
lag_corrs <- numeric(length(lags))
par(mfrow = c(1, length(lags)), mar = c(4,4,3,1))
for (i in seq_along(lags)) {
k <- lags[i]
if (length(values) > k) {
y <- values[(k+1):length(values)]
x <- values[1:(length(values)-k)]
ok <- !is.na(x) & !is.na(y)
plot(x[ok], y[ok], pch=16, col=rgb(0,0,1,0.5), cex=0.5,
xlab=sprintf("%s(t-%d)", asset, k), ylab=sprintf("%s(t)", asset),
main=sprintf("Lag %d %s", k, ifelse(k==1,"day","days"))); grid()
if (sum(ok) > 1) {
r <- cor(x[ok], y[ok]); lag_corrs[i] <- r
text(min(x[ok]) + 0.05*diff(range(x[ok])),
max(y[ok]) - 0.05*diff(range(y[ok])),
sprintf("Corr: %.3f", r), pos=4)
}
}
}
par(mfrow = c(1,1))
invisible(lag_corrs)
}

plot_acf_pacf <- function(asset, lags = 40) {
vals <- price_data[[asset]] |> stats::na.omit()
par(mfrow=c(2,1), mar=c(4,4,3,1))
acf(vals,  lag.max=lags, main=paste(asset,"- ACF"));  grid()
pacf(vals, lag.max=lags, main=paste(asset,"- PACF")); grid()
par(mfrow=c(1,1))
}

adf_print <- function(asset) {
vals <- price_data[[asset]] |> stats::na.omit()
res  <- tseries::adf.test(vals, alternative="stationary")
cat(sprintf("ADF Statistic: %.4f\np-value: %.4f\nConclusion: %s\n",
res$statistic, res$p.value,
ifelse(res$p.value<0.05,"STATIONARY (reject H0)","NON-STATIONARY (fail to reject H0)")))
invisible(res)
}

make_stationary <- function(asset) {
vals <- price_data[[asset]] |> stats::na.omit()
tr <- list(original = vals,
first_diff = diff(vals),
second_diff = diff(diff(vals)))
if (all(vals > 0)) {
tr$log      <- log(vals)
tr$log_diff <- diff(log(vals))
}
cat(sprintf("Stationarity tests for %s transformations:\n", asset))
cat(strrep("-", 40), "\n")
par(mfrow=c(2,2), mar=c(3,4,3,1))
shown <- 0
for (nm in names(tr)) {
x <- tr[[nm]]
if (length(x) > 10) {
res <- tseries::adf.test(x, alternative="stationary")
status <- ifelse(res$p.value < 0.05, "✓ STATIONARY", "✗ Non-stationary")
cat(sprintf("  %-12s | ADF: %7.3f | p: %.4f | %s\n", nm, res$statistic, res$p.value, status))
if (shown < 4) {
plot(x, type="l", main=nm, ylab="Value", xlab=""); grid()
shown <- shown + 1
}
}
}
par(mfrow=c(1,1))
invisible(NULL)
}

moving_average_panel <- function(asset, windows = c(5,20,60,120)) {
vals  <- price_data[[asset]]; dates <- price_data$Date
plot(dates, vals, type="l", col="black", lwd=1,
main=paste(asset,"- Moving Average Smoothing"),
xlab="Date", ylab="Value", ylim=range(vals, na.rm=TRUE)); grid()
cols <- c("red","green","blue","purple","orange")
legend_text <- c("Original"); legend_cols <- c("black"); idx <- 1
for (w in windows) {
if (length(vals) > w) {
ma <- zoo::rollmean(vals, k=w, fill=NA, align="center")
lines(dates, ma, col=cols[idx], lwd=2)
legend_text <- c(legend_text, paste0("MA-", w))
legend_cols <- c(legend_cols, cols[idx]); idx <- idx + 1
}
}
legend("topleft", legend = legend_text, col = legend_cols, lwd = 2, bty = "n")

# quick text stats

cat(sprintf("Variance reduction & correlations for %s:\n", asset))
base_var <- var(vals, na.rm=TRUE)
for (w in windows) {
if (length(vals) > w) {
ma <- zoo::rollmean(vals, k=w, fill=NA, align="center")
ma_var <- var(ma, na.rm=TRUE)
vr <- (base_var - ma_var)/base_var*100
r  <- cor(vals, ma, use="complete.obs")
cat(sprintf("  MA-%3d: Var↓ %5.1f%% | Corr %.3f\n", w, vr, r))
}
}
invisible(NULL)
}

```


## Bitcoin

::: {.panel-tabset}

### Time Series Plot
```{r}
#| warning: false
plot_ts_with_trend("Bitcoin")
component_analysis_print("Bitcoin")
```

### Moving Average Smoothing
```{r}
#| warning: false
moving_average_panel("Bitcoin")
```

### Lag Plots
```{r}
#| warning: false
create_lag_plots("Bitcoin")
```

### ACF & PACF
```{r}
#| warning: false
plot_acf_pacf("Bitcoin")
```

### Dickey Fuller Test
```{r}
#| warning: false
adf_print("Bitcoin")
```

### Stationary
```{r}
#| warning: false
make_stationary("Bitcoin")
```

:::


## S&P 500

::: {.panel-tabset}

### Time Series Plot
```{r}
#| warning: false
plot_ts_with_trend("SP500")
component_analysis_print("SP500")
```

### Moving Average Smoothing
```{r}
#| warning: false
moving_average_panel("SP500")
```

### Lag Plots
```{r}
#| warning: false
create_lag_plots("SP500")
```

### ACF & PACF
```{r}
#| warning: false
plot_acf_pacf("SP500")
```

### Dickey Fuller Test
```{r}
#| warning: false
adf_print("SP500")
```

### Stationary
```{r}
#| warning: false
make_stationary("SP500")
```

:::


## NASDAQ

::: {.panel-tabset}

### Time Series Plot
```{r}
#| warning: false
plot_ts_with_trend("NASDAQ")
component_analysis_print("NASDAQ")
```

### Moving Average Smoothing
```{r}
#| warning: false
moving_average_panel("NASDAQ")
```

### Lag Plots
```{r}
#| warning: false
create_lag_plots("NASDAQ")
```

### ACF & PACF
```{r}
#| warning: false
plot_acf_pacf("NASDAQ")
```

### Dickey Fuller Test
```{r}
#| warning: false
adf_print("NASDAQ")
```

### Stationary
```{r}
#| warning: false
make_stationary("NASDAQ")
```

:::


## USD INDEX

::: {.panel-tabset}

### Time Series Plot
```{r}
#| warning: false
plot_ts_with_trend("USD")
component_analysis_print("USD")
```

### Moving Average Smoothing
```{r}
#| warning: false
moving_average_panel("USD")
```

### Lag Plots
```{r}
#| warning: false
create_lag_plots("USD")
```

### ACF & PACF
```{r}
#| warning: false
plot_acf_pacf("USD")
```

### Dickey Fuller Test
```{r}
#| warning: false
adf_print("USD")
```

### Stationary
```{r}
#| warning: false
make_stationary("USD")
```

:::


## VIX

::: {.panel-tabset}

### Time Series Plot
```{r}
#| warning: false
plot_ts_with_trend("VIX")
cat("\nComponent analysis (VIX):\n")
component_analysis_print("VIX")
```

### Moving Average Smoothing
```{r}
#| warning: false
moving_average_panel("VIX")
```

### Lag Plots
```{r}
#| warning: false
create_lag_plots("VIX")
```

### ACF & PACF
```{r}
#| warning: false
plot_acf_pacf("VIX")
```

### Dickey Fuller Test
```{r}
#| warning: false
adf_print("VIX")
```

### Stationary
```{r}
#| warning: false
make_stationary("VIX")
```

:::

```{r}
#| warning: false
cat("EDA SUMMARY AND CONCLUSIONS")

# Stationarity summary (levels)

assets <- c("Bitcoin","SP500","VIX")
cat("\nSTATIONARITY (Levels):\n")
for (a in assets) {
res <- try(tseries::adf.test(stats::na.omit(price_data[[a]]), alternative="stationary"), silent=TRUE)
if (inherits(res,"try-error")) next
status <- ifelse(res$p.value < 0.05, "STATIONARY", "NON-STATIONARY")
cat(sprintf("  %-8s : %s (p=%.4f)\n", a, status, res$p.value))
}

# Basic vol & correlations on returns (where available)

if (all(c("Bitcoin_ret","SP500_ret") %in% colnames(returns))) {
cat("\nKEY FINDINGS:\n")
btc_sd <- sd(returns$Bitcoin_ret); sp_sd <- sd(returns$SP500_ret)
cat(sprintf("  • Bitcoin daily std: %.4f | S&P 500 daily std: %.4f\n", btc_sd, sp_sd))
r_b_s  <- cor(returns$Bitcoin_ret, returns$SP500_ret, use="complete.obs")
cat(sprintf("  • BTC–S&P 500 correlation (daily returns): %.3f\n", r_b_s))
if (r_b_s > 0.3) {
cat("    → Moderate positive comovement; BTC behaving as a risk asset in-sample")
} else {
cat("    → Low comovement; BTC retains alternative characteristics")
}
}


```

Bitcoin shows the highest volatility with frequent large spikes, while SPX is smoother, VIX is jumpy, and USD is very stable. Correlations reveal that SPX and VIX are strongly inversely related, while Bitcoin moves largely independently of the others. Overall, the assets behave as expected: equities and fear are tightly linked, crypto is noisy, and the USD is stable.